#!/usr/bin/env php
<?php

/**
 * Inbox and Task Engine
 *
 * This is the bootstrap file for processing all local actions
 * and committing them to the IMAP server. It also syncs the
 * main Inbox folder more frequently than the full sync.
 */
use App\Log;
use App\Sync;
use App\Model;
use App\Inbox;
use App\Message;
use App\Startup;
use App\Constants;
use App\Diagnostics;
use Pimple\Container;
use Slim\PDO\Database;
use Exception as Exception;
use React\EventLoop\Factory;
use App\Console\InboxConsole;
use MKraemer\ReactPCNTL\PCNTL;
use PDOException as PDOException;
use App\Exceptions\Stop as StopException;
use App\Exceptions\Terminate as TerminateException;
use Symfony\Component\EventDispatcher\EventDispatcher as Emitter;

// Set up paths and constants
set_time_limit( 0 );
define( 'BASEPATH', __DIR__ );
// User UTF-8
mb_internal_encoding( 'UTF-8' );
//date_default_timezone_set( 'UTC' );
define( 'DBSCRIPTS', BASEPATH .'/db/*.sql' );

// Load configuration files and parse the CLI arguments
$constants = parse_ini_file( BASEPATH .'/config/constants.ini', FALSE );
$default = parse_ini_file( BASEPATH .'/config/default.ini', TRUE );
$local = parse_ini_file( BASEPATH .'/config/local.ini', TRUE );
$config = array_replace_recursive( $default, $local );

// Set the memory limit from the config
ini_set( 'memory_limit', $config[ 'app' ][ 'memory' ] );
ini_set( 'mysql.connect_timeout', $config[ 'sql' ][ 'timeout' ] );
ini_set( 'default_socket_timeout', $config[ 'sql' ][ 'timeout' ] );

// Load the vendor libraries
require( BASEPATH .'/vendor/autoload.php' );

// Process constants
Constants::process( $constants );
unset( $constants );

// Set up dependency container and register all services
$di = new Container;

// Store the configuration as a service
$di[ 'config' ] = $config;

// Console/CLI service
$di[ 'console' ] = new InboxConsole( $config );
$di[ 'cli' ] = function ( $c ) {
    return $c[ 'console' ]->getCLI();
};

// Set up the event dispatcher
$di[ 'emitter' ] = new Emitter;

// Diagnostic test service
$di[ 'diagnostics' ] = function ( $c ) {
    return new Diagnostics( $c );
};

// Logging service
$di[ 'log' ] = function ( $c ) {
    return new Log(
        $c[ 'cli' ],
        $c[ 'config' ][ 'inboxlog' ],
        $c[ 'console' ]->interactive === TRUE );
};

// Initialize the error and exception handlers
$di[ 'log' ]->init();

// React event loop
$di[ 'loop' ] = Factory::create();

// Set up the signal handler to shutdown
$TERMINATE = function () {
    throw new TerminateException;
};

// Graceful shutdown
$HALT = function () use ( $di ) {
    if ( isset( $di[ 'inbox' ] ) && $di[ 'inbox' ] ) {
        $di[ 'inbox' ]->halt();
    }
};

// Set up process handler bindings for React
$pcntl = new PCNTL( $di[ 'loop' ] );
$pcntl->on( SIGHUP, $TERMINATE );
$pcntl->on( SIGINT, $TERMINATE );
$pcntl->on( SIGTERM, $TERMINATE );
$pcntl->on( SIGQUIT, $TERMINATE );

// Inbox processes tasks and syncs the inbox
$di[ 'inbox' ] = new Inbox(
    $di[ 'log' ]->getLogger(),
    $di[ 'cli' ],
    $di[ 'loop' ],
    $di[ 'console' ],
    $config[ 'inbox' ] );

// PDO factory, this uses Slim-PDO as a wrapper
$di[ 'db_factory' ] = $di->factory( function ( $c, $config = NULL ) {
    $dbConfig = ( $config ) ?: $c[ 'config' ][ 'sql' ];
    $dsn = sprintf(
        "mysql:host=%s;dbname=%s;charset=%s",
        $dbConfig[ 'hostname' ],
        $dbConfig[ 'database' ],
        $dbConfig[ 'charset' ] );

    try {
        $db = new Database(
            $dsn,
            $dbConfig[ 'username' ],
            $dbConfig[ 'password' ] );
        $db->query( 'SET SESSION wait_timeout = 28800;' );
        $db->query( 'SET NAMES '. $dbConfig[ 'charset' ] .';' );

        return $db;
    }
    catch ( PDOException $e ) {
        throw new TerminateException(
            "There was a problem connecting to the database. ".
            "Are you sure it exists? Here are the details: ".
            $e->getMessage() );
    }
});

// Run the diagnostic tests. If specified from the CLI, then
// output the results to the console and exit.
$di[ 'diagnostics' ]->runInbox();

// PDO connection. This attempts to connect to the database.
// If it fails here, the script will halt.
$di[ 'db' ] = $di[ 'db_factory' ];

// Statically set the services in the base model
Model::setDb( $di[ 'db' ] );
Model::setCLI( $di[ 'cli' ] );
Model::setConfig( $di[ 'config' ] );
Model::setLog( $di[ 'log' ]->getLogger() );

// Statically set Message logging service
Message::setLog( $di[ 'log' ]->getLogger() );

// Parse the CLI
$di[ 'console' ]->init();

// Run initialization checks, like if the database exists or if there
// are email accounts saved. This may prompt the user to add an account
// if we're running in interactive mode.
try {
    $startup = new Startup( $di );
    $startup->runInbox();
    $di[ 'inbox' ]->run();

    runLoop: {
        $di[ 'loop' ]->stop();
        $di[ 'loop' ]->run();
    }
}
// If the database connection dropped, kill the database service and
// try to reconnect. Otherwise terminate.
catch ( PDOException $e ) {
    $sec = $config[ 'app' ][ 'db' ][ 'sleep_minutes' ] * 60;
    Diagnostics::checkDatabaseException( $di, $e, TRUE, $sec );
    goto runLoop;
}
// Gracefully exit if we're terminated
catch ( TerminateException $e ) {
    $di[ 'log' ]->getLogger()->addInfo( $e->getMessage() );
    exit( 0 );
}
// Unhandled exceptions
catch ( Exception $e ) {
    $di[ 'log' ]->displayError( $e );
}
