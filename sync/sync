#!/usr/bin/php
<?php

/**
 * Sync Engine
 *
 * This is the bootstrap file for the email syncing engine, called
 * from the CLI or managed via a supervisor. It works by checking
 * a list of saved IMAP credentials and runs through a flow of tasks.
 */

use App\Log
  , App\Sync
  , App\Model
  , App\Console
  , App\Startup
  , App\Constants
  , Pimple\Container
  , Slim\PDO\Database;

// Set up paths and constants
set_time_limit( 0 );
define( 'BASEPATH', __DIR__ );
date_default_timezone_set( 'UTC' );
define( 'DBSCRIPTS', BASEPATH .'/db/*.sql' );

// Load the vendor libraries
require( BASEPATH .'/vendor/autoload.php' );

// Load configuration files and parse the CLI arguments
$constants = parse_ini_file( BASEPATH .'/config/constants.ini', FALSE );
$default = parse_ini_file( BASEPATH .'/config/default.ini', TRUE );
$local = parse_ini_file( BASEPATH .'/config/local.ini', TRUE );
$config = array_replace_recursive( $default, $local );
Constants::process( $constants );
unset( $constants );

// Set up dependency container and register all services
$di = new Container();

// Store the configuration as a service
$di[ 'config' ] = $config;

// Console/CLI service
$di[ 'console' ] = new Console( $config );
$di[ 'cli' ] = function ( $c ) {
    return $c[ 'console' ]->getCLI();
};

// MySQLi service, this uses Voku's library
$di[ 'db' ] = function ( $c ) {
    $dbConfig = $c[ 'config' ][ 'sql' ];
    $dsn = sprintf(
        "mysql:host=%s;dbname=%s;charset=%s",
        $dbConfig[ 'hostname' ],
        $dbConfig[ 'database' ],
        $dbConfig[ 'charset' ] );

    try {
        return new Database(
            $dsn,
            $dbConfig[ 'username' ],
            $dbConfig[ 'password' ] );
    }
    catch ( \PDOException $e ) {
        $c[ 'log' ]->getLogger()->addError(
            "There was a problem connecting to the database. ".
            "Are you sure it exists? Here are the details: ".
            $e->getMessage() );
        exit( 0 );
    }
};

// Logging service
$di[ 'log' ] = function ( $c ) {
    $interactive = ( $c[ 'console' ]->interactive === TRUE );
    return new Log( $c[ 'cli' ], $c[ 'config' ][ 'log' ], $interactive );
};

// Set the memory limit from the config
ini_set( 'memory_limit', $di[ 'config' ][ 'app' ][ 'memory' ] );

// Initialize the error and exception handlers
$di[ 'log' ]->init();

// Statically set the services in the base model
Model::setDb( $di[ 'db' ] );
Model::setCLI( $di[ 'cli' ] );
Model::setConfig( $di[ 'config' ] );
Model::setLog( $di[ 'log' ]->getLogger() );

// Parse the CLI
$di[ 'console' ]->init();

// Run initialization checks, like if the database exists or if there
// are email accounts saved. This may prompt the user to add an account
// if we're running in interactive mode.
try {
    $sleepMinutes = $di[ 'config' ][ 'app' ][ 'sync' ][ 'sleep_minutes' ];
    $startup = new Startup( $di );
    $startup->run();

    while ( TRUE ) {
        $sync = new Sync( $di );
        
        if ( ! $sync->run() ) {
            exit( 0 );
        }

        $di[ 'log' ]->getLogger()->addInfo(
            "Going to sleep for $sleepMinutes minutes (brb)" );
        $sync = NULL;
        sleep( $sleepMinutes * 60 );
    }
}
catch ( \Exception $e ) {
    if ( $di[ 'console' ]->interactive === TRUE ) {
        $di[ 'cli' ]->boldRedBackgroundBlack( $e->getMessage() );
        $di[ 'cli' ]->dim( "[Err#". $e->getCode() ."]" );

        if ( $config[ 'log' ][ 'stacktrace' ] ) {
            $di[ 'cli' ]->br()->comment( $e->getTraceAsString() )->br();
        }
    }
    else {
        if ( $config[ 'log' ][ 'stacktrace' ] ) {
            $di[ 'log' ]->getLogger()->addError(
                $e->getMessage() . PHP_EOL . $e->getTraceAsString() );
        }
        else {
            $di[ 'log' ]->getLogger()->addError( $e->getMessage() );
        }
    }
}
